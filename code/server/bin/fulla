#!/usr/bin/env perl
use v5.22;
use warnings;

use IO::Socket::INET;
use Proc::Daemon;

use Log::Log4perl ':easy';
use DBI;

use Fulla::Werchzueg;
use Fulla::CommandDispatcher;
use Fulla::Dos;

# basic help message for -h and --help
if (defined $ARGV[0] and $ARGV[0] =~ /^-h$|^--help$/) {
    say "\n\tsee 'man fulla' for documentation\n";
    exit 0;
}

# are we a daemon? If any argument is given, we DON'T daemonize
my $i_am_a_daemon = 1;
   $i_am_a_daemon = 0 if defined $ARGV[0];

my $daemon;
if ($i_am_a_daemon) {
    # help the poor souls, in controlling the daemon
    say '';
    say "\tHi, I'm a daemon\n";
    say "\tkill me:\t\tpkill -F /tmp/fulla.pid";
    say "\twatch me:\t\ttail -f fulla.*";
    say "\tdon't run me as daemon:\tfulla test";
    say '';

    # daemonize process
    $daemon = Proc::Daemon->new( work_dir     => "$ENV{PWD}",
                                 pid_file     => "/tmp/fulla.pid",
                                 child_STDOUT => 'fulla.stdout',
                                 child_STDERR => 'fulla.stderr',
                               );
    $daemon->Init();
}

# setting up logger config
my $log_config = { level  => $DEBUG,
                   layout => '%d %F{1} (%L) -> %m%n',
                 };
# log to file if in daemon mode
$log_config->{file} = "$ENV{PWD}/fulla.log" if $i_am_a_daemon;

# create logger object
Log::Log4perl->easy_init($log_config);
my $log = Log::Log4perl->get_logger();

# since we have a logger, we can say that we have started :-)
$log->info('starting server');

# log process id
if ($i_am_a_daemon) {
    my ($pid, $pid_file) = $daemon->get_pid();
    $log->info('process id '      . $pid);
    $log->info('process id file ' . $pid_file);
}
else {
    $log->info('not running as daemon, argv is: ' . join(', ', @ARGV));
}

# setting up DB connection
my $dbh = DBI->connect( 'DBI:mysql:database=fulla;host=localhost;',
                        'root',
                        'gibbiX12345',
                      );
if ($dbh) {
    $log->info('db connection established');
}
else {
    $log->fatal($DBI::errstr);
    die        ($DBI::errstr);
}
$dbh->do('set names utf8');

# register db and logger globally (singleton pattern)
Fulla::Werchzueg->set_database($dbh);
Fulla::Werchzueg->set_logger  ($log);

# initialise object for parsing and dispatching incoming commands
my $dispatcher = Fulla::CommandDispatcher->new();

# configure "auto-flush": no buffering in print to console
$| = 1;
 
# creating a listening socket
my $socket = new IO::Socket::INET (
    LocalAddr     => '0.0.0.0',     # local server address
    LocalPort     => '7777',        # local server port
    Listen        => 5,             # queue size for connections
    Proto         => 'tcp',         # protocol used
);
$log->fatal("cannot create socket $!") unless $socket;
die         "cannot create socket $!"  unless $socket;
$log->info('server waiting for client connection on port 7777');

# this variable controls the main loop of the process
my $continue = 1;

# signal handlers for terminating the process
$SIG{'INT'} = sub { $log->info('ctrl+c pressed') if $log;
                    $socket->close()             if $socket;
                    $continue = 0;
                  };
$SIG{TERM}  = sub { $log->info('I got killed')   if $log;
                    $socket->close()             if $socket;
                    $continue = 0;
                  };

# any incoming IP must have had at least one second pause
my $dos = Fulla::Dos->new(min_pause => 1);

# endless loop, looking for client requests
while($continue)
{
    # waiting for a new client connection
    my $client_socket = $socket->accept();

    unless ($client_socket) {
        $log->error("socket accept failed $!");
        next;
    }
 
    # get information about a newly connected client
    my $client_address = $client_socket->peerhost();
    my $client_port    = $client_socket->peerport();
    $log->info("connection from $client_address:$client_port");

    # don't answer dos attacks
    if ($dos->check($client_address)) {
		$log->warn("client blocked: $client_address:$client_port");
        print $client_socket "00000000000000000000 dos from $client_address";
        shutdown($client_socket, 1);
        next;
	}

    # read up to 1024 characters from the connected client
    my $client_data = '';
    sysread( $client_socket, $client_data, 1024);
    $log->info("received data: $client_data");

    # do whatever needs to be done
    my $answer = $dispatcher->do($client_data);
    $log->debug("answer: $answer");

    # write response data to the connected client
    print $client_socket $answer;
 
    # notify client that response has been sent
    shutdown($client_socket, 1);

    $log->info("request from $client_address:$client_port answered");
}
 
# always clean up your room
END {
    $log->info('bye bye') if $log;
    $socket->close()      if $socket;
}

# Some helpfull links on how to write a TCP application #
#########################################################
# http://xmodulo.com/how-to-write-simple-tcp-server-and-client-in-perl.html
# https://metacpan.org/pod/IO::Socket::INET
# https://metacpan.org/pod/IO::Socket::SSL

__END__

=encoding UTF-8

=head1 NAME

B<fulla> - executable to start the C<Fulla> server.

This module is part of the C<Fulla> project.

=head1 SYNOPSIS

To start the server in the terminal, just type

 fulla

If you want to save some logs, you can redirect C<stdin> and C<stdout>

 fulla &> fulla_logs_$(date +%F).log

=head1 LIBRARY

All additional server code can be found under the perl namespace C<Fulla>.

=head1 AUTHOR

© Boris Däppen, Biel, 2017
